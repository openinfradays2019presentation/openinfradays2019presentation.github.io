---
title: truly-understanding-container
pdf: truly-understanding-container.pdf
slideNumber: true
controls: true
---

# Truly understainding container {bg=#444444 .light-on-dark}

*이어형*

# Me: 어형부형

<img src="assets/al.jpg" style="width:300px;"/>

<font size="6">KT: openstack 기반 public storage 서비스 개발,운영</font>

<font size="6">Kakao: openstack 기반 private cloud 서비스 개발,운영</font>

<small>현재</small> <font size="6"> Line: kubernetes 기반 private cloud native 서비스 개발,운영</font>

# 주제 {bg=#444444 .light-on-dark}

컨테이너란 무엇인가 다시 생각해보고    

컨테이너의 <font color="red">**한계**</font>라고 여겨지는 것들에 대해    

해결할 수 있는 방법들을 살펴보며    

이로 향후 컨테이너의 나아갈 방향을 생각해봅니다.

# ![잘못 끼워진 첫 단추](assets/shirt.jpg)

Container와 Virtual machine은 비교대상인가?

<aside class="notes">
잘못 끼워진 첫 단추

우리는 container를 배울때 virtual machine과의 차이점 부터 배운다.
</aside>

# Container and Virtual Machine의 같은점

사용자의 <font color="red">**workload**</font>를 처리

그렇다면 다른 점은?

# 구조?

# ![Container vs Virtual Machine](assets/cvsv.png)

Container vs Virtual Machine

<small>[image from docker blog](https://blog.docker.com/2018/08/containers-replacing-virtual-machines/)</small>

# 성능?

# <img src="assets/performance.png" style="width:700px;"/>
Container vs Virtual Machine - IOPS

<small>[image from An Updated Performance Comparison of Virtual Machines and Linux Containers](http://course.ece.cmu.edu/~ece845/docs/containers.pdf)</small>

# 성능이 떨어지는 이유는 구조 때문인가?

# <img src="assets/virtio.png" style="width:700px;"/>
Container vs Virtual Machine - virtio

<small>[image from An Updated Performance Comparison of Virtual Machines and Linux Containers](http://course.ece.cmu.edu/~ece845/docs/containers.pdf)</small>

# virtio, QEMU의 존재 이유?

#

<img src="assets/emulation.png" style="width:700px;"/>

emulation - 본뜸

<small>[image from unlimitedtomorrow](https://www.unlimitedtomorrow.com/)</small>

# emulation

장점: <font color="red">**호환성**</font>을 제공하여 종래의 것을    
     그대로 치환(or 이전)가능함

단점: 모방하기 위한 비용(성능 등)이 큼

# 그러면 container는?

# 최초에는 isolation만이 고려

emulation의 오버헤드 없이 사용하고자 했음

# os container로 시작

VM이 `hardware virtualization`이라면

container는 `os virtualization` 라고 했던 시절이..

# os container vs app container

<img src="assets/osvsapp.png" style="width:600px;"/>

<small>[image from The Missing Introduction To Containerization](https://medium.com/faun/the-missing-introduction-to-containerization-de1fbb73efc5)</small>

#

![History of Container](assets/history.png)

# app container를 한마디로 한다면?

#

<img src="assets/robot-machine-simulation.png" style="width:700px;"/>

simulation - 모의실험

[from talumis](https://www.talumis.com/what-is-simulation/)

# 그러면 왜 simulation 이라 하는가?

결과를 예측가능하게 만들기 위해서    
<font color="red">**재사용성**</font>을 높인다.

이 과정에서 <font color="red">**최적화**</font>가 가능

*== 컨테이너 특성과 유사*

# 그러면 무엇에 대한 simulation인가?

physical machine이 아닌 <font color="red">**process**</font>

# 그러면 무엇으로 simlation을 제어하는가?

<font color="red">**cgroup**</font>과 <font color="red">**namespace**</font>

# cgroup과 namespace

cgroup: resource(memory, cpu, ...)을 관리하기 위한 기술

namespace: 논리적인 독립공간을 제공하기 위한 기술

# namespace 종류

mnt : mount

uts : hostname

ipc : SystemV IPC

pid : process

net : network

uid : user ID

***time , syslog namespace not exist***

# namespace의 의미

어디에서나 해당 namespace의 내용이    

유지되거나 조작가능하여 <font color="red">**재사용성**</font>을 높임

# 어떻게 namespace를 생성하는가?

*[unshare](http://man7.org/linux/man-pages/man2/unshare.2.html) - disassociate parts of the process execution context*

#

```
$ # 이미지 추출
$ docker export blissful_goldstine -o dockercontainer.tar
$ mkdir rootfs
$ tar xf dockercontainer.tar --ignore-command-error -C rootfs/
$ # container 생성
$ unshare --mount --uts --ipc --net --pid --user \
   --fork --map-root-user chroot $PWD/rootfs ash
root:# mount -t proc none /proc
root:# mount -t sysfs none /sys
root:# mount -t tmpfs none /tmp
```

이를 이용해서 컨테이너 생성 가능

<small>[image from how-to-run-docker-containers-using-common-linux-tools-without-docker](https://ilearnedhowto.wordpress.com/2017/12/13/how-to-run-docker-containers-using-common-linux-tools-without-docker/)</small>

# 다만 아직 남은게 있음

resource는 분할 했지만 아직 사용량제어를 하지 않음

그래서 여기에 cgroup을 적용해야 함

# 그리고 마지막으로

network을 외부 연결해줘야 함

현재의 network는 갇힌 외부로 연결이 불가능한    
network namespace 상태

그래서 namespace를 가로지르는 통신방법이 필요

# veth: virtual ethernet

pair로 존재하며 다른 namespace에 동일하게 존재하여

한 pair로 들어온 트래픽은 다른 pair의 veth로 복사됨

![](assets/container_namespaces.png)

<small>[image from Container Namespaces – Deep Dive into Container Networking](https://platform9.com/blog/container-namespaces-deep-dive-container-networking/)</small>

# 최적화된 방법이란?

# 예 - IP 할당

||virtaul machine|container|
|----|-----|-----|
|예(IP할당)|실제 dhcp를 L2 layer로 broadcasting 한 후에 결과로 IP를 받음|dhcp를 사용하지 않고 container의 가상의 interface에 IP를 부여|
|의미|dhcp를 그대로 사용가능하여 physical machine등도 같이 사용가능|IP를 dhcp가 아닌 다른 방법으로 관리가 필요해짐|

# 예 - container에게 restart가 필요한가?

kubernetes엔 container의 restart가 없음

왜 없을까?

[kubectl 참고](https://kubernetes.io/docs/reference/kubectl/overview/#operations)

<aside class="notes">
workload를 restart하는 것은 그것에 의미를 부여하여 stateful 함을 만들어 cattle이 아닌 pet을 만드는 길입니다.

restart 대신에 delete 하면 kubernetes에서 새로 생성하게 되고 우리는 굳이 restart 에 대해 디자인 하기 보다 delete 할때 처리해야 하는 일과 start 할때 처리해야 하는 일에 집중해서 stateless 하게 만듭니다.
</aside>

# Virtual machine vs container 목표

* VM: <font color="red">**physical machine**</font>의 기능을 최대한 닮게 소프트웨어로 구현
* app container: <font color="red">**process**</font>가 해야하는 목표를 재현율을 높이며 최적화된 방법을 소프트웨어로 구현

*결국 physical machine 과 process의 차이 관점으로 봐야함*

# 결국 

이전보다 더 좁은 scope로    
보다 목표 중심적으로 사고를 할 수 있게 됨

container를 사용하면서 기존의 방식을    
재정의하여 최적화 한 방법들이 나타남

이는 <font color="red">**cloud native**</font>로 연결됨

# container의 한계 {bg=#444444 .light-on-dark}

# docker와 container와의 관계

old: docker **is** container

new: docker **is** container `platform`

# docker의 문제

# unregister netdevice error

아직까지 해결되지 않은    
커널 패닉을 유발하는 문제가 존재

<small>[from kernel-crash-after-unregister_netdevice-waiting-for-lo-to-become-free-usage-count-3](https://www.bountysource.com/issues/2004254-kernel-crash-after-unregister_netdevice-waiting-for-lo-to-become-free-usage-count-3)</small>

# docker daemon에 종속성이 있음

docker restart시 컨테이너에 영향

docker socket이 죽을 시 컨테이너에 영향

# 한계 #1

너무 많은 기능을 가지고 있는    
`docker daemon`의 종속성으로    
한번에 노드가 망가지기가 쉽다.

# 우선 그러면 docker는 대체 가능 한가?

# runtimes

![](assets/runtimes.png)

<small>[from container-runtimes-part-1-introduction-container-r](https://www.ianlewis.org/en/container-runtimes-part-1-introduction-container-r)</small>

# kubernetes container runtime interface

docker 없이 container를 사용하기 위한 interface들이 제공됨

<img src="assets/docker-ce.png" style="width:600px;"/>

<small>[from kubernetes-containerd-integration-goes-ga](https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/)</small>

# containerd

단순성, 견고성, 휴대성을 중시한    
산업 표준 container runtime

<img src="assets/containerd-1.png" style="width:400px;"/>

# containerd performance

<img src="assets/cpu.png" style="width:600px;"/>

# 다만 새로운 runtime들을 사용시

대부분 이름 그대로 runtime만 가지고 있음

build는 별도

# 그렇다면 build는?

# buildkit

동시성, 캐시 효율성 이 있으며    
Dockerfile에 구속받지않는 빌더 툴킷

<img src="assets/buildkit.png" style="width:600px;"/>

<small>[from Building Efficient Docker Container Images with BuildKit](https://www.xenonstack.com/blog/container-images-with-buildkit/)</small>

# 결론

새로운 runtime을 사용하면    
buildtime, runtime을 구분 함    

이를 통해 container service에서는    
오직 runtime만 사용하여 보안성 및 성능 향상

# 한계 #2

docker는 `root`만이 해당 OS에 설치가능 

취약점 발생시 OS레벨    
문제 일으킬 가능성들이 존재함

# root로 사용하는 컨테이너들

`USER` syntax등을 사용하지 않으면 기본적으로 root 이기에

일반적으로 root user를 사용해서 docker를 이용

```
$ docker run -ti busybox whoami
root
```

# 외부 device 혹은 directory mount시 일반 user사용이 힘든

권한 문제발생

```
$ cat Dockerfile 
...

# Add chrome user
RUN groupmod -g 995 audio \
    && groupmod -g 986 video \
    && groupadd -g 1000 -r chrome \
    && useradd -u 1000 -r -g chrome -G audio,video chrome \
    && mkdir -p /home/chrome/Downloads \
	&& chown -R chrome:chrome /home/chrome

...

# Run Chrome as non privileged user
USER chrome

# Autorun chrome
ENTRYPOINT [ "google-chrome" ]
CMD [ "--user-data-dir=/data" ]
```

<small>[from leoh0 dockerfiles](https://github.com/leoh0/dotfiles/blob/master/.dockerfunc#L1280-L1308)</small>

# root로 사용하는 컨테이너들

일반적으로 root를 사용해서 docker를 이용

```
vscode(){
	docker run -d \
		-v /etc/localtime:/etc/localtime:ro \
		-v /tmp/.X11-unix:/tmp/.X11-unix  \
		-v /usr/share/fonts:/usr/share/fonts \
		-v /usr/lib/locale/locale-archive:/usr/lib/locale/locale-archive \
		-v "${HOME}/.vscode/extension:/home/user/.vscode" \
		-v "${HOME}/.vscode/config:/home/user/.config" \
		-e "GTK_IM_MODULE=uim" \
		-e "XMODIFIERS=@im=uim" \
		-e "QT_IM_MODULE=uim" \
		-e "LC_ALL=ko_KR.UTF-8" \
		-v "$(pwd):/project" \
		-e "DISPLAY=unix${DISPLAY}" \
		--device /dev/dri \
		--name visualstudio \
		leoh0/vscode \
		bash -c 'su user -p -c "/usr/share/code/code /project"'
}
```
#TODO 일반유저를 줘서 사용시 uid, gid 치환문제가 발생

# rootless container

root 권한이없는 사용자가     
컨테이너를 작성, 실행 및 관리 할 수있음

<small>[from rootlesscontaine.rs](https://rootlesscontaine.rs/)</small>

# 이런건 rootless container가 아님

* `docker run --user foo`
* Dockerfile 안에 `USER` 
* `usermod -aG docker foo`
* `sudo docker` or `chmod +s dockerd`
* `dockerd --userns-remap`

<small>[from rootlesscontaine.rs](https://rootlesscontaine.rs/)</small>

# podman

Podman linux 시스템에서 OCI 컨테이너를    
개발, 관리 및 실행하기 위한 데몬이 없는 컨테이너 엔진

`alias docker=podman`.

<img src="assets/podman.svg" style="width:600px;"/>

[from podman](https://podman.io/)

# 데몬 없는 podman

podman 커맨드가 직접 linux에 접근해서 모든것을 실행

<img src="assets/fig2.png" style="width:400px;"/>

[from podman-and-buildah-for-docker-users](https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/)

# binctr

실행 가능한 바이너리로서 완전 정적이고 권한없이도 실행가능한 독립적 인 컨테이너.

[from binctr](https://github.com/genuinetools/binctr)

# binctr 예

<section>
    <video autoplay=true class="stretch" src="assets/binctr.mp4"></video>
</section>

[from kakaotalk-binctr](https://github.com/leoh0/kakaotalk-binctr/)

# 과정

#TODO 이쁘게 수정

<small>

바이너리 실행 ->

컨테이너 스펙 생성 ->

바이너리 안에 미리 넣은 이미지를 압축 풀어서 rootfs를 만듬 ->

컨테이너 실행 ->

컨테이너 안에서 이 바이너리를 실행 이때 뒤에 인자 init을 붙여서 분기 ->

컨테이너 안에서 다시 이 바이너리가 실행되면서    
위의 rootfs로 pivot하여 위의 컨테이너 스펙으로 실행
</small>

# 이를 구현한 주요 코드

```
package main

import (
	"flag"
	"os"
	"runtime"

	"github.com/leoh0/binctr/container"
	"github.com/opencontainers/runc/libcontainer"
	_ "github.com/opencontainers/runc/libcontainer/nsenter"
	specs "github.com/opencontainers/runtime-spec/specs-go"
	"github.com/sirupsen/logrus"
)

const (
	defaultRoot      = "/tmp/kakaotalk-binctr"
	defaultRootfsDir = "rootfs"
)

var (
	containerID string
	root        string

	file      string
	dir       string
	shortpath string
)

func init() {
	// Parse flags
	flag.StringVar(&containerID, "id", "kakaotalk", "container ID")
	flag.StringVar(&root, "root", defaultRoot, "root directory of container state, should be tmpfs")

	flag.Usage = func() {
		flag.PrintDefaults()
	}

	flag.Parse()
}

//go:generate go run generate.go
func main() {
	if len(os.Args) > 1 && os.Args[1] == "init" {
		runInit()
		return
	}

	dir := os.Getenv("HOME") + "/.kwine"
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		err = os.MkdirAll(dir, 0755)
		if err != nil {
			panic(err)
		}
	}

	// Create a new container spec with the following options.
	opts := container.SpecOpts{
		Rootless: false,
		Terminal: false,
		Args: []string{
			"/usr/local/bin/entrypoint.sh",
		},
		Env: []string{
			"LANG=ko_KR.UTF-8",
			"LANGUAGE=ko_KR.UTF-8",
			"GTK_IM_MODULE=uim",
			"XMODIFIERS=@im=uim",
			"QT_IM_MODULE=uim",
			"DISPLAY=unix:0",
			"PULSE_SERVER=tcp:127.0.0.1:4713",
			"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
		},
		Mounts: []specs.Mount{
			{
				Destination: "/etc/localtime",
				Type:        "bind",
				Source:      "/etc/localtime",
				Options:     []string{"ro", "rbind", "rprivate"},
			},
			{
				Destination: "/tmp/.X11-unix",
				Type:        "bind",
				Source:      "/tmp/.X11-unix",
				Options:     []string{"rw", "rbind", "rprivate"},
			},
			{
				Destination: "/root/.wine",
				Type:        "bind",
				Source:      dir,
				Options:     []string{"rw", "rbind", "rprivate"},
			},
		},
	}
	spec := container.Spec(opts)

	// Initialize the container object.
	c := &container.Container{
		ID:               containerID,
		Spec:             spec,
		Root:             root,
		Rootless:         false,
		Detach:           false,
		NoPivotRoot:      true,
		UseSystemdCgroup: false,
		HostNetwork:      true,
		ShareIPC:         true,
	}

	// Unpack the rootfs.
	if err := c.UnpackRootfs(defaultRootfsDir, Asset); err != nil {
		logrus.Fatal(err)
	}

	// Run the container.
	status, err := c.Run()
	if err != nil {
		logrus.Fatal(err)
	}

	// Remove the rootfs after the container has exited.
	if err := os.RemoveAll(defaultRootfsDir); err != nil {
		logrus.Warnf("removing rootfs failed: %v", err)
	}

	// Exit with the container's exit status.
	os.Exit(status)
}

func runInit() {
	runtime.GOMAXPROCS(1)
	runtime.LockOSThread()
	factory, _ := libcontainer.New("")
	if err := factory.StartInitialization(); err != nil {
		// as the error is sent back to the parent there is no need to log
		// or write it to stderr because the parent process will handle this
		os.Exit(1)
	}
	panic("libcontainer: container init failed to exec")
}
```

# 이런 방법외에도

coreOS

linuxkit

등과 같은 공격받을 범위를 줄이는    
적은 공격 범위를 갖는 전문 컨테이너 호스트를 사용

# 결론

가능한 적은 root 권한을 이용하도록 함

가능한 적은 권한을 같는 OS 기반에서 사용하도록 함

# 한계 #3

container는 VM과 달리 multi tenant를    
위한 isolation이 적합하지 못하다.

# multi tenant

#TODO multi tenant가 왜 필요 한지?

# kubesprawl

#TODO kubesprawl 에 대한 설명

https://tech.paulcz.net/blog/future-of-kubernetes-is-virtual-machines/

# isolation 정도

<img src="assets/image1.png" style="width:700px;"/>

[from making-containers-more-isolated-an-overview-of-sandboxed-container-technologies](https://unit42.paloaltonetworks.com/making-containers-more-isolated-an-overview-of-sandboxed-container-technologies/)

# kubernetes soft multi tenancy

#TODO namespace 소개
namespace

# kubernetes hard multi tenancy

<img src="assets/mtimage2.png" style="width:700px;"/>

[hard-multi-tenancy-in-kubernetes](https://blog.jessfraz.com/post/hard-multi-tenancy-in-kubernetes/)


# sandboxed containers

a.k.a micro vm

<img src="assets/sandbox.png" style="width:700px;"/>

[from making-containers-more-isolated-an-overview-of-sandboxed-container-technologies](https://unit42.paloaltonetworks.com/making-containers-more-isolated-an-overview-of-sandboxed-container-technologies/)

# 결론

기존의 VM의 강점을 가저가면서도    
container의 최적화된 장점들을 가져갈 수 있는 방법들이    
여러가지로 경쟁적으로 나오고 있는 상태

# 마지막으로

<img src="assets/vm.png" style="width:700px;"/>

# 감사합니다.

